// Map Container Component

import { useEffect, useRef, useState, useCallback, forwardRef, useImperativeHandle } from 'react';

import styled from 'styled-components';

import { useLocations, useLocationStore } from '../../../stores/location';

import { LocationMarker } from './LocationMarker';

import { CreateLocationModal } from './CreateLocationModal';

import { useNaverMap } from '../../../hooks/useNaverMap';

import { logger } from '../../../utils/logger';

import type { LocationResponse } from '../../../types';



interface MapContainerProps {

  onLocationSelect?: (location: LocationResponse) => void;

  className?: string;

}



export interface MapContainerRef {

  panToLocation: (lat: number, lng: number, zoom?: number) => void;

}



export const MapContainer = forwardRef<MapContainerRef, MapContainerProps>(({

  onLocationSelect,

  className

}, ref) => {

  logger.info('üöÄ MapContainer component rendering...');



  const [isMapLoaded, setIsMapLoaded] = useState(false);

  const [isLoadingLocations, setIsLoadingLocations] = useState(false);

  const [isModalOpen, setIsModalOpen] = useState(false);

  const [clickedPosition, setClickedPosition] = useState<{

    lat: number;

    lng: number;

    address?: string;

  } | undefined>(undefined);

  // Î™®Î∞îÏùº Î°±ÌîÑÎ†àÏä§ Í∞êÏßÄÎ•º ÏúÑÌïú ÏÉÅÌÉú
  const [touchStartTime, setTouchStartTime] = useState<number>(0);

  const [touchStartPos, setTouchStartPos] = useState<{x: number, y: number} | null>(null);

  const lastBoundsRef = useRef<{ne: {lat: number, lng: number}, sw: {lat: number, lng: number}} | null>(null);



  const locations = useLocations();

  const selectedLocation = useLocationStore((state) => state.selectedLocation);

  const shouldFocusOnMap = useLocationStore((state) => state.shouldFocusOnMap);



  const { mapRef, map, isLoaded } = useNaverMap({

    center: { lat: 37.5665, lng: 126.9780 }, // ÏÑúÏö∏ ÏãúÏ≤≠

    zoom: 13,

    options: {

      // ÏßÄÎèÑ Ïù∏ÌÑ∞ÎûôÏÖò ÌôúÏÑ±Ìôî

      scaleControl: true,

      logoControl: true,

      mapDataControl: true,

      zoomControl: true,

    }

  });



  // Expose map control methods via ref

  useImperativeHandle(ref, () => ({

    panToLocation: (lat: number, lng: number, zoom?: number) => {

      if (!map || !isLoaded) {

        logger.warn('Map not loaded yet');

        return;

      }



      const newCenter = new window.naver.maps.LatLng(lat, lng);



      // Ï§å Î†àÎ≤®Ïù¥ ÏßÄÏ†ïÎêú Í≤ΩÏö∞, Î®ºÏ†Ä Ï§åÏùÑ ÏÑ§Ï†ïÌïòÍ≥† Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÜÏù¥ Ïù¥Îèô

      if (zoom !== undefined) {

        map.setZoom(zoom);

      }



      // Í∑∏ Îã§Ïùå Î∂ÄÎìúÎüΩÍ≤å Ï§ëÏã¨ Ïù¥Îèô

      setTimeout(() => {

        map.panTo(newCenter, { duration: 500 });

      }, 100);



      logger.info('Map panned to location', { lat, lng, zoom });

    }

  }), [map, isLoaded]);



  // boundsÍ∞Ä Ïú†ÏùòÎØ∏ÌïòÍ≤å Î≥ÄÍ≤ΩÎêòÏóàÎäîÏßÄ ÌôïÏù∏ÌïòÎäî Ìï®Ïàò - useCallbackÏúºÎ°ú Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖò

  const hasBoundsChanged = useCallback((newBounds: {ne: {lat: number, lng: number}, sw: {lat: number, lng: number}}) => {

    if (!lastBoundsRef.current) return true;



    const prev = lastBoundsRef.current;

    const THRESHOLD = 0.001; // ÏïΩ 100m Ï†ïÎèÑÏùò Î≥ÄÌôîÎüâ



    return (

      Math.abs(newBounds.ne.lat - prev.ne.lat) > THRESHOLD ||

      Math.abs(newBounds.ne.lng - prev.ne.lng) > THRESHOLD ||

      Math.abs(newBounds.sw.lat - prev.sw.lat) > THRESHOLD ||

      Math.abs(newBounds.sw.lng - prev.sw.lng) > THRESHOLD

    );

  }, []);



  // API Ìò∏Ï∂ú Ìï®Ïàò - useCallbackÏúºÎ°ú Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖò

  const fetchLocationsWithBounds = useCallback(async (bounds: {ne: {lat: number, lng: number}, sw: {lat: number, lng: number}}) => {

    if (!hasBoundsChanged(bounds) || isLoadingLocations) {

      logger.info('üîÑ API Ìò∏Ï∂ú Ïä§ÌÇµ - bounds Î≥ÄÌôî ÏóÜÏùå ÎòêÎäî Î°úÎî© Ï§ë');

      return;

    }



    try {

      setIsLoadingLocations(true);

      const fetchLocationsByBounds = useLocationStore.getState().fetchLocationsByBounds;

      const currentGroupId = useLocationStore.getState().currentGroupId;



      await fetchLocationsByBounds(bounds.ne, bounds.sw, undefined, currentGroupId || undefined);

      lastBoundsRef.current = bounds;



      logger.info('‚úÖ Locations Î°úÎìú ÏôÑÎ£å', bounds);

    } catch (error) {

      logger.error('‚ùå Locations Î°úÎìú Ïã§Ìå®', error);

    } finally {

      setIsLoadingLocations(false);

    }

  }, [hasBoundsChanged, isLoadingLocations]);



  // ÏßÄÎèÑ Î°úÎìú ÏôÑÎ£å Ï≤òÎ¶¨

  useEffect(() => {

    if (map && isLoaded) {

      setIsMapLoaded(true);

      logger.info('üó∫Ô∏è Map Î°úÎìú ÏôÑÎ£å');



      // Ï¥àÍ∏∞ ÏúÑÏπò Îç∞Ïù¥ÌÑ∞ Î°úÎìú - ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ÏùÑ ÎëêÍ≥† Ïã§Ìñâ

      const timer = setTimeout(() => {

        try {

          const bounds = map.getBounds && map.getBounds();

          if (bounds) {

            let northEast, southWest;



            try {

              if (typeof bounds.getNorthEast === 'function') {

                northEast = bounds.getNorthEast();

                southWest = bounds.getSouthWest();

              } else if (typeof bounds.getMax === 'function') {

                northEast = bounds.getMax();

                southWest = bounds.getMin();

              } else {

                // Fallback for unknown bounds structure

                northEast = (bounds as unknown as Record<string, unknown>).northEast as { lat: number; lng: number };

                southWest = (bounds as unknown as Record<string, unknown>).southWest as { lat: number; lng: number };

              }



              if (northEast && southWest) {

                const boundsData = {

                  ne: {

                    lat: typeof northEast.lat === 'function' ? northEast.lat() : northEast.lat,

                    lng: typeof northEast.lng === 'function' ? northEast.lng() : northEast.lng

                  },

                  sw: {

                    lat: typeof southWest.lat === 'function' ? southWest.lat() : southWest.lat,

                    lng: typeof southWest.lng === 'function' ? southWest.lng() : southWest.lng

                  }

                };



                fetchLocationsWithBounds(boundsData);

              }

            } catch (boundsError) {

              logger.warn('üöß ÏßÄÎèÑ bounds Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®', boundsError);

            }

          }

        } catch (error) {

          logger.error('‚ùå Ï¥àÍ∏∞ ÏúÑÏπò Î°úÎî© Ïò§Î•ò', error);

        }

      }, 1000);



      return () => clearTimeout(timer);

    }

  }, [map, isLoaded, fetchLocationsWithBounds]);



  // ÏßÄÎèÑ Ïù¥Îèô Ïãú ÏúÑÏπò Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ - idle Ïù¥Î≤§Ìä∏ ÏÇ¨Ïö©

  useEffect(() => {

    if (!map || !isLoaded) return;



    const handleMapIdle = () => {

      try {

        const bounds = map.getBounds();

        if (bounds) {

          let northEast, southWest;



          try {

            if (typeof bounds.getNorthEast === 'function') {

              northEast = bounds.getNorthEast();

              southWest = bounds.getSouthWest();

            } else if (typeof bounds.getMax === 'function') {

              northEast = bounds.getMax();

              southWest = bounds.getMin();

            } else {

              // Fallback for unknown bounds structure

              northEast = (bounds as unknown as Record<string, unknown>).northEast as { lat: number; lng: number };

              southWest = (bounds as unknown as Record<string, unknown>).southWest as { lat: number; lng: number };

            }



            if (northEast && southWest) {

              const boundsData = {

                ne: {

                  lat: typeof northEast.lat === 'function' ? northEast.lat() : northEast.lat,

                  lng: typeof northEast.lng === 'function' ? northEast.lng() : northEast.lng

                },

                sw: {

                  lat: typeof southWest.lat === 'function' ? southWest.lat() : southWest.lat,

                  lng: typeof southWest.lng === 'function' ? southWest.lng() : southWest.lng

                }

              };



              fetchLocationsWithBounds(boundsData);

            }

          } catch (boundsError) {

            logger.warn('üöß ÏßÄÎèÑ idle Ïãú bounds Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®', boundsError);

          }

        }

      } catch (error) {

        logger.error('‚ùå ÏßÄÎèÑ idle Ìï∏Îì§Îü¨ Ïò§Î•ò', error);

      }

    };



    // idle Ïù¥Î≤§Ìä∏Îäî ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÄÎèÑ Ï°∞ÏûëÏùÑ Î©àÏ∂ò ÌõÑ Î∞úÏÉù

    const listener = window.naver.maps.Event.addListener(map, 'idle', handleMapIdle);



    return () => {

      window.naver.maps.Event.removeListener(listener);

    };

  }, [map, isLoaded, fetchLocationsWithBounds]);



  const handleLocationClick = (location: LocationResponse) => {

    onLocationSelect?.(location);

    logger.userAction('Location marker clicked', { locationId: location.id });

  };



  // Ïö∞ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨

  const handleRightClick = useCallback((e: { coord: { lat: () => number; lng: () => number } }) => {

    const lat = e.coord.lat();

    const lng = e.coord.lng();



    logger.info('Map right-clicked', { lat, lng });



    // TODO: Î∞±ÏóîÎìú Reverse Geocoding API Ïó∞Îèô ÌõÑ Ï£ºÏÜå ÏûêÎèô Ï°∞Ìöå Íµ¨ÌòÑ

    setClickedPosition({ lat, lng });

    setIsModalOpen(true);

  }, []);



  // Î™®Î∞îÏùº Î°±ÌîÑÎ†àÏä§ Ìï∏Îì§Îü¨
  const handleTouchStart = useCallback((e: any) => {
    const coord = e.coord;
    if (coord && typeof coord.x === 'function' && typeof coord.y === 'function') {
      setTouchStartTime(Date.now());
      setTouchStartPos({ x: coord.x(), y: coord.y() });
    }
  }, []);

  const handleTouchEnd = useCallback((e: any) => {
    const touchDuration = Date.now() - touchStartTime;
    const LONG_PRESS_DURATION = 500; // 500ms Ïù¥ÏÉÅ ÎàÑÎ•¥Í∏∞

    if (touchDuration >= LONG_PRESS_DURATION && touchStartPos) {
      const coord = e.coord;
      if (coord && typeof coord.x === 'function' && typeof coord.y === 'function') {
        const deltaX = Math.abs(coord.x() - touchStartPos.x);
        const deltaY = Math.abs(coord.y() - touchStartPos.y);

        // Ïù¥ÎèôÏù¥ 10px ÎØ∏ÎßåÏù¥Î©¥ Î°±ÌîÑÎ†àÏä§Î°ú Ïù∏Ïãù
        if (deltaX < 10 && deltaY < 10) {
          const lat = e.coord.lat();
          const lng = e.coord.lng();

          logger.info('Map long-pressed (mobile)', { lat, lng, duration: touchDuration });
          setClickedPosition({ lat, lng });
          setIsModalOpen(true);
        }
      }
    }

    setTouchStartTime(0);
    setTouchStartPos(null);
  }, [touchStartTime, touchStartPos]);



  // Ïö∞ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Îì±Î°ù

  useEffect(() => {

    if (!map || !isLoaded) return;



    const listener = window.naver.maps.Event.addListener(map, 'rightclick', handleRightClick);



    return () => {

      window.naver.maps.Event.removeListener(listener);

    };

  }, [map, isLoaded, handleRightClick]);



  // Î™®Î∞îÏùº Î°±ÌîÑÎ†àÏä§ Ïù¥Î≤§Ìä∏ Îì±Î°ù
  useEffect(() => {
    if (!map || !isLoaded) return;

    const touchStartListener = window.naver.maps.Event.addListener(map, 'touchstart', handleTouchStart);
    const touchEndListener = window.naver.maps.Event.addListener(map, 'touchend', handleTouchEnd);

    return () => {
      window.naver.maps.Event.removeListener(touchStartListener);
      window.naver.maps.Event.removeListener(touchEndListener);
    };
  }, [map, isLoaded, handleTouchStart, handleTouchEnd]);



  // "ÏßÄÎèÑÏóêÏÑú Î≥¥Í∏∞" Î≤ÑÌäº ÌÅ¥Î¶≠ ÏãúÏóêÎßå ÏßÄÎèÑ Ï§ëÏã¨ Ïù¥Îèô

  useEffect(() => {

    if (!map || !isLoaded || !selectedLocation || !shouldFocusOnMap) return;



    const { latitude, longitude } = selectedLocation;

    if (!latitude || !longitude) return;



    // ÏßÄÎèÑ Ï§ëÏã¨ÏùÑ ÏÑ†ÌÉùÎêú ÏúÑÏπòÎ°ú Î∂ÄÎìúÎüΩÍ≤å Ïù¥Îèô

    const newCenter = new window.naver.maps.LatLng(latitude, longitude);

    map.panTo(newCenter, { duration: 500 }); // 500ms Ïï†ÎãàÎ©îÏù¥ÏÖò



    // Ï§å Î†àÎ≤®ÏùÑ 15Î°ú ÏÑ§Ï†ï (ÏÉÅÏÑ∏ Î≥¥Í∏∞)

    if (map.getZoom() < 15) {

      map.setZoom(15, true); // trueÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò ÌôúÏÑ±Ìôî

    }



    logger.info('Map centered on selected location', { latitude, longitude });

  }, [map, isLoaded, selectedLocation, shouldFocusOnMap]);



  const handleModalClose = () => {

    setIsModalOpen(false);

    setClickedPosition(undefined);

  };



  return (

    <Container className={className}>

      <MapDiv ref={mapRef} />



      {!isLoaded && (

        <LoadingOverlay>

          <LoadingSpinner />

          <LoadingText>ÏßÄÎèÑÎ•º Î°úÎìúÌïòÎäî Ï§ë...</LoadingText>

        </LoadingOverlay>

      )}



      {isMapLoaded && map && locations && locations.map(location => (

        <LocationMarker

          key={location.id}

          map={map}

          location={location}

          onClick={handleLocationClick}

        />

      ))}



      <MapControls>

        <LocationCount>

          üìç {locations?.length || 0}Í∞ú Ï†ÄÏû•

          {isLoadingLocations && ' (Î°úÎî© Ï§ë...)'}

        </LocationCount>

      </MapControls>



      <CreateLocationModal

        isOpen={isModalOpen}

        onClose={handleModalClose}

        initialPosition={clickedPosition}

      />

    </Container>

  );

});



const Container = styled.div`

  position: relative;

  width: 100%;

  height: 100%;

  background-color: #f0f0f0;

`;



const MapDiv = styled.div`

  width: 100%;

  height: 100%;

`;



const LoadingOverlay = styled.div`

  position: absolute;

  top: 0;

  left: 0;

  right: 0;

  bottom: 0;

  background-color: rgba(255, 255, 255, 0.9);

  display: flex;

  flex-direction: column;

  align-items: center;

  justify-content: center;

  z-index: 1000;

`;



const LoadingSpinner = styled.div`

  width: 3rem;

  height: 3rem;

  border: 4px solid #e2e8f0;

  border-top: 4px solid #3182ce;

  border-radius: 50%;

  animation: spin 1s linear infinite;

  margin-bottom: 1rem;



  @keyframes spin {

    0% { transform: rotate(0deg); }

    100% { transform: rotate(360deg); }

  }

`;



const LoadingText = styled.p`

  color: #4a5568;

  font-size: 1rem;

  text-align: center;

  margin: 0;

`;



const MapControls = styled.div`

  position: absolute;

  top: 20px;

  left: 50%;

  transform: translateX(-50%);

  display: flex;

  flex-direction: column;

  gap: 12px;

  z-index: 1001;

`;



const LocationCount = styled.div`

  background: white;

  padding: 8px 12px;

  border-radius: 8px;

  font-size: 14px;

  font-weight: 500;

  color: #2d3748;

  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);

  border: 1px solid #e2e8f0;

`;


